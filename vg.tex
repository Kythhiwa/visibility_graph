\documentclass{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}


\usepackage{amsmath,amssymb,amsthm}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{authblk} 

\theoremstyle{definition}
\newtheorem{definition}{Определение}
\newtheorem{theorem}{Теорема}

\begin{document}

\title{Оптимизация алгоритма построения графа видимости}
\date{\today}

%\issue{2026}{1}{edu}
%\setcounter{page}{1}
%\journalsection{informatics}
%\articletype{Научная статья}

\author[1]{Баринов М. А.}
\author[2]{Павлов Д. А.}
\affil[1]{СПбГЭТУ «ЛЭТИ», факультет компьютерных технологий и информатики}
\affil[2]{СПбГЭТУ «ЛЭТИ», факультет компьютерных технологий и информатики}

\maketitle

\begin{abstract}
  \end{abstract}

\section{Введение}

Планирование оптимальной траектории для точечного агента на плоскости с полигональными препятствиями
является фундаментальной задачей вычислительной геометрии и робототехники.
Её практическая значимость охватывает такие области, как навигация мобильных роботов (в том числе беспилотных автомобилей),
анализ зон видимости в геоинформационных системах, компьютерное зрение и разработка компьютерных игр.
Суть задачи состоит в нахождении траектории минимальной евклидовой длины, соединяющей заданные начальную
и конечную точки и не пересекающей внутренности непересекающихся многоугольных препятствий.

Классическим подходом к решению этой задачи является построение графа видимости вершин,
в котором вершины препятствий соединяются ребрами, если они видят друг друга.
Поиск кратчайшего пути в таком графе гарантирует оптимальность решения.
Существует ряд эффективных алгоритмов построения графа видимости.
В частности, алгоритм Гоша-Маунта \cite{ghosh87} (Ghosh-Mount),
предложенный в 1987 году, решает эту задачу за время
$O(E + n \log n)$, где $E$ — число ребер в итоговом графе, а $n$ — общее
число вершин препятствий. Ключевая идея этого метода заключается в
использовании триангуляции пространства и особой структуры данных —
«воронок» (funnels), что позволяет добавлять новые вершины и ребра в граф
по одной, тратя время пропорционально только реально появляющимся связям.

Альтернативный класс методов составляют алгоритмы с произвольными углами
(any-angle path planning)~\cite{nash07theta,nash10lazy,harabor16anya}, которые
работают непосредственно на сеточных картах, позволяя повороты под любым углом.
Вот некоторые из них:
\begin{itemize}
    \item \textbf{Theta* и Lazy Theta*} --- модификации A*, использующие проверку 
    прямой видимости между вершинами для спрямления пути;
    \item \textbf{ANYA} --- находит оптимальные пути под любым углом, ограничивая пространство поиска узкими путями 
        (путь, где каждое изменение направления пути «обвивается» вокруг какого-либо препятствия); 
        рассматривая интервал точек как узел, а не как отдельную точку. 
        Этот алгоритм ограничен двумерными сетками.
    \item \textbf{Field D*} --- алгоритм динамического поиска пути на основе D*, 
        использующий интерполяцию при каждом расширении вершины для нахождения почти оптимальных путей через регулярные, 
        неравномерные сетки стоимости.
\end{itemize}

Стоит отметить, что помимо прикладных алгоритмов поиска пути, в литературе активно исследуются
различные теоретические модификации графов видимости, расширяющие представление о структуре пространства.
Так, в работе О'Рурка и Стрейну \cite{orourke98vertexedge} был предложен и проанализирован
\textbf{вершинно-рёберный граф видимости}, в котором учитываются не только связи между вершинами,
но и видимость вершин до ребер препятствий. Авторы показали, что такая структура содержит больше
информации о геометрии сцены, позволяя, например, однозначно определять тип вершин и восстанавливать
деревья кратчайших путей. Хотя данная работа носит преимущественно теоретический характер,
подобные результаты могут служить основой для разработки более информированных методов планирования маршрутов.


\subsection*{Историческая справка}

Задача поиска кратчайшего пути в среде с препятствиями имеет богатую историю. 
Впервые понятие графа видимости было введено Нильсоном в 1968 году в контексте 
решения задачи планирования пути для мобильного робота Shakey~\cite{nilsson69}. 
Им же было доказано, что кратчайший путь между двумя точками среди многоугольных 
препятствий обязан проходить через их вершины.

В 1979 году Ли предложил первый эффективный алгоритм построения графа видимости 
со сложностью $O(n^2 \log n)$~\cite{lee78,coleman2012visibility}. Этот алгоритм использовал метод 
заметающего луча и стал основополагающим для дальнейших исследований.

С развитием многоядерных процессоров в 2000-х годах акцент сместился в сторону 
параллельных реализаций классических алгоритмов.

\section{Формальная постановка задачи}
\label{sec:problem}

Пусть заданы:
\begin{enumerate}[label=\textbf{\arabic*.}]
    \item \textbf{Пространство:} Евклидова плоскость $\mathbb{R}^2$.
    \item \textbf{Начальная и конечная точки:} $S, T \in \mathbb{R}^2$, $S \neq T$.
    \item \textbf{Множество препятствий:} $\mathcal{P} = \{P_1, P_2, \dots, P_k\}$ --- конечный набор простых многоугольников, таких что:
    \begin{itemize}
        \item $\forall i \neq j: P_i \cap P_j = \varnothing$ (многоугольники не пересекаются);
        \item $S, T \notin \bigcup_{i=1}^k \operatorname{int}(P_i)$, где $\operatorname{int}(P_i)$ --- внутренность многоугольника $P_i$.
    \end{itemize}
\end{enumerate}

\begin{definition}[Допустимая траектория]
\textbf{Допустимой траекторией} называется непрерывное отображение $\phi: [0, 1] \to \mathbb{R}^2$, удовлетворяющее условиям:
\begin{itemize}
    \item $\phi(0) = S$, $\phi(1) = T$;
    \item $\forall t \in (0, 1): \phi(t) \notin \bigcup_{i=1}^k \operatorname{int}(P_i)$.
\end{itemize}
Траектория может касаться границ препятствий $\partial P_i$.
\end{definition}

\begin{definition}[Длина траектории]
Для допустимой траектории $\phi$ её \textbf{евклидова длина} определяется как:
\[
L(\phi) = \sup \left\{ \sum_{i=1}^{n} \|\phi(t_i) - \phi(t_{i-1})\| \ \middle| \ 0 = t_0 < t_1 < \dots < t_n = 1 \right\},
\]
где $\| \cdot \|$ --- евклидова норма в $\mathbb{R}^2$.
\end{definition}

\begin{definition}[Оптимальная траектория]
Допустимая траектория $\phi^*$ называется \textbf{оптимальной} (кратчайшей), если
\[
L(\phi^*) = \min \{ L(\phi) \mid \phi \text{ --- допустимая траектория} \}.
\]
\end{definition}

\section{Граф видимости}
\label{sec:visibility-graph}

Ключевым инструментом решения задачи является дискретизация пространства с помощью графа видимости.

\subsection{Построение графа}

\begin{definition}[Множество вершин]
Множество вершин графа видимости есть объединение всех вершин препятствий и начальной с конечной точками:
\[
V = \{S, T\} \cup \bigcup_{i=1}^k V(P_i),
\]
где $V(P_i)$ --- множество вершин многоугольника $P_i$.
\end{definition}

\begin{definition}[Ребро видимости]
Для двух различных вершин $u, v \in V$ отрезок $[u, v]$ называется \textbf{видимым}, если
\[
[u, v] \cap \left( \bigcup_{i=1}^k \operatorname{int}(P_i) \right) = \varnothing,
\]
где $[u, v] = \{\lambda u + (1-\lambda)v \mid \lambda \in [0, 1]\}$ --- замкнутый отрезок.
\end{definition}

\begin{definition}[Граф видимости]
\textbf{Графом видимости} называется взвешенный неориентированный граф $G = (V, E, w)$, где:
\begin{itemize}
    \item $V$ --- множество вершин, определённое выше;
    \item $E \subseteq V \times V$ --- множество рёбер, такое что $(u, v) \in E$ тогда и только тогда, когда $u \neq v$ и отрезок $[u, v]$ видим;
    \item $w: E \to \mathbb{R}^+$ --- функция весов, заданная евклидовым расстоянием: $w(u, v) = \|u - v\|_2$.
\end{itemize}
\end{definition}

\subsection{Основная теорема}

Следующая теорема устанавливает фундаментальную связь между исходной непрерывной задачей и задачей поиска пути в графе.
Она была доказана Нильсоном~\cite{nilsson69} и позднее уточнена Ли~\cite{lee78}.

\begin{theorem}[Основное свойство графа видимости]
Пусть $\phi^*: [0,1] \to \mathbb{R}^2$ --- оптимальная траектория в исходной задаче, а $G = (V, E, w)$ --- соответствующий граф видимости. Тогда:
\begin{enumerate}[label=\textbf{(\arabic*)}]
    \item \textbf{Существование дискретного пути:} Существует путь $p = (v_0, v_1, \dots, v_m)$ в графе $G$, где $v_0 = S$, $v_m = T$, такой что
    \[
    L(\phi^*) = \sum_{j=0}^{m-1} \|v_{j+1} - v_j\|_2 = \sum_{(u,v) \in p} w(u,v).
    \]
    
    \item \textbf{Структура оптимальной траектории:} Оптимальная траектория $\phi^*$ является ломаной линией,
        вершины которой принадлежат множеству $V$: $\{v_0, v_1, \dots, v_m\} \subseteq V$.
    
    \item \textbf{Эквивалентность задач:} Кратчайший путь в исходной задаче соответствует кратчайшему пути в графе $G$:
    \[
    \min_{\phi \ \text{допустимая}} L(\phi) = \min_{p \ \text{путь в} \ G \ \text{из} \ S \ \text{в} \ T} \sum_{(u,v) \in p} w(u,v).
    \]
\end{enumerate}
\end{theorem}

\subsection{Алгоритмическое следствие}

На основании теоремы поиск кратчайшей траектории в непрерывной области сводится к следующей двухэтапной процедуре:

\begin{enumerate}
    \item \textbf{Построение графа видимости} $G = (V, E, w)$ для заданных препятствий $\mathcal{P}$ и точек $S$, $T$.
    \item \textbf{Поиск кратчайшего пути} в графе $G$ из вершины $S$ в вершину $T$ с использованием стандартных алгоритмов теории графов, 
        таких как алгоритм Дейкстры или A*.
\end{enumerate}

Сложность решения в первую очередь определяется построением графа, которое в наивной реализации требует $O(|V|^2)$ проверок видимости
для каждой пары вершин, где $|V| = 2 + \sum_{i=1}^k |V(P_i)|$. 

\section{Построение графа видимости}
\label{sec:construction}
Для начала примем, что все препятствия обходятся против часовой стрелки, так чтобы внутренность каждого препятствия находилась слева от направления обхода.

\subsection{Наивный подход}

Наивная реализация процедуры построения графа видимости $G=(V,E,w)$ основана на полном переборе всех возможных пар вершин
и проверке видимости соответствующего отрезка.

\begin{enumerate}[label=\textbf{Шаг \arabic*.}]
    \item Формируется множество вершин $V = \{S, T\} \cup \bigcup_{i=1}^k V(P_i)$.
    \item Для каждой упорядоченной пары вершин $(u, v) \in V \times V$, где $u \neq v$, проверяется условие видимости отрезка $[u, v]$.
    \item Если отрезок $[u, v]$ видим, то в множество рёбер $E$ добавляется неориентированное ребро $(u, v)$ с весом $w(u,v) = \|u - v\|_2$.
\end{enumerate}

Сложность данного подхода определяется количеством пар вершин, равным $O(|V|^2)$,
и стоимостью проверки видимости одного отрезка, которая в наивной реализации составляет $O(n)$,
где $n$ --- общее количество рёбер во всех препятствиях. Таким образом, итоговая сложность составляет $O(|V|^2 \cdot n)$, 
что делает метод неэффективным для сцен со сложной геометрией.

\subsection{Оптимальный алгоритм на основе заметающего луча (Алгоритм Ли)}

Для эффективного построения графа видимости применяется алгоритм, предложенный Ли,
сложность которого составляет $O(|V|^2 \log |V|)$ в худшем случае.
Алгоритм последовательно для каждой вершины $s \in V$ (называемой \emph{источником}) определяет все другие видимые из неё вершины.

Идея метода: будем вращать луч вокруг источника $s$ и отслеживать, какие рёбра препятствий пересекает этот луч в данный момент. 
Ближайшее к $s$ пересечение определяет, закрыта ли очередная вершина каким-либо препятствием

\begin{definition}[Заметающий луч]\label{def:processing_ray}
Для источника $s$ и текущей вершины $v$ \textbf{заметающим лучом} $L(s, v)$ называется луч с началом в $s$, проходящий через $v$.
\end{definition}

\begin{definition}[Статус луча]\label{def:ray_status}
\textbf{Статусом} на текущем угле обхода называется упорядоченное множество (например, сбалансированное дерево) рёбер препятствий,
которые пересекает заметающий луч $L(s, v)$. Рёбра упорядочены по возрастанию расстояния от точки $s$ до точки пересечения с лучом.
\end{definition}

\subsubsection{Основные этапы для одного источника}

Алгоритм для фиксированного источника $s$ состоит из следующих этапов.

\begin{enumerate}[label=\textbf{Этап \arabic*.}]
    \item \textbf{Подготовка и сортировка.}
    \begin{itemize}
        \item Все вершины $v \in V \setminus \{s\}$ проецируются на полярную систему координат с полюсом в $s$.
        \item Вершины сортируются в порядке возрастания полярного угла $\theta(s, v)$. При равенстве углов приоритет отдаётся вершине, ближайшей к $s$.
        \item Для каждого ребра $e$ препятствия, \emph{видимого} из $s$ (т.е. хотя бы один конец $e$ видим из $s$),
            определяются события: ``начало отрезка'' и ``конец отрезка'', 
            соответствующие моментам, когда вращающийся луч $L$ совпадает с направлением на концы $e$.
    \end{itemize}

    \item \textbf{Инициализация.}
    \begin{itemize}
        \item Луч $L$ устанавливается в направлении $\theta = 0$ (например, горизонтально вправо).
        \item В статус заносятся все рёбра препятствий, которые пересекает луч в этом начальном положении, упорядоченные по расстоянию от $s$.
    \end{itemize}

    \item \textbf{Последовательная обработка событий.}
    \begin{itemize}
        \item События обрабатываются в порядке возрастания полярного угла.
        \item При наступлении события ``вершина $v$'':
        \begin{itemize}
            \item Если статус пуст, то вершина $v$ \emph{видима} из $s$, и ребро $(s, v)$ добавляется в граф.
            \item Если статус не пуст, то $v$ видима только если отрезок $[s, v]$ не пересекается с ближайшим к $s$ ребром из статуса
                (т.е. $v$ находится ближе к $s$, чем точка пересечения луча $L(s, v)$ с этим ребром).
        \end{itemize}
        \item При наступлении события ``начало отрезка $e$'': ребро $e$ добавляется в статус,
            если при его рассмотрении выполняется условие обхода \emph{против часовой стрелки} для точек ($s$, начало $e$, конец $e$).
        \item При наступлении события ``конец отрезка $e$'': ребро $e$ удаляется из статуса,
            если при его рассмотрении выполняется условие обхода \emph{по часовой стрелке} для точек ($s$, конец $e$, начало $e$).
    \end{itemize}
\end{enumerate}


После завершения обработки всех событий для источника $s$ мы получаем все видимые из $s$ вершины.
Повторяя процедуру для каждого $s \in V$, строим полный граф видимости.
Использование сбалансированных деревьев для хранения статуса обеспечивает сложность $O(\log |V|)$ на операцию вставки или удаления ребра,
что приводит к общей сложности $O(|V|^2 \log |V|)$ для построения всего графа.

\section{Оптимизация}

Несмотря на эффективность алгоритма Ли, построенный граф видимости содержит значительное число ребер,
которые заведомо не могут принадлежать ни одному кратчайшему пути. Выявление и исключение таких ребер
на этапе построения позволяет сократить как время построения графа, так и время последующего поиска пути.

\begin{definition}[Локальная конфигурация вершины]
Для вершины $cur$, принадлежащей некоторому препятствию $P_i$, определим ее \textbf{соседей} вдоль границы этого препятствия. 
Пусть $\operatorname{prev}(cur)$ и $\operatorname{next}(cur)$ --- вершины, непосредственно предшествующая и следующая за $cur$ 
при обходе контура многоугольника $P_i$. Для начальной и конечной точек $S, T$, 
не лежащих на границах препятствий, множество соседей считается пустым.
\end{definition}

\begin{theorem}[Критерий незначащего ребра]
\label{thm:minor_edge}
Пусть $u, v \in V$ --- две различные вершины графа видимости, и пусть отрезок $[u, v]$ является видимым. 
Обозначим через $l_{uv}$ прямую, проходящую через точки $u$ и $v$. 
Ребро $(u, v)$ называется \textbf{незначащим} (\emph{minor edge}), если для каждой из этих вершин выполняются следующие условия:
\begin{itemize}
    \item вершина принадлежит некоторому препятствию;
    \item ее соседи вдоль границы этого препятствия существуют;
    \item эти соседи лежат по разные стороны от прямой $l_{uv}$.
\end{itemize}
Такое ребро не может принадлежать ни одному кратчайшему пути в графе видимости и может быть исключено из рассмотрения
(рис. \ref{fig:minor_edge}, красным цветом выделено такое ребро, а зеленым допустимые).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{images/5.png}
    \caption{Незначащее ребро}
    \label{fig:minor_edge}
\end{figure}


\end{theorem}

А также:

\begin{enumerate}
    \item Можно заметить следующее: 
    если мы имеем две вершины $u$ и $v$ такие, что первая из них расположена ниже второй 
    (то есть ее $y$-координата меньше), тогда при обработке вершины $v$ ребро $(u,v)$ 
    либо будет проведено, если оно допустимо, либо не будет. Следовательно, можно не рассматривать вершины, 
    у которых $y$-координата меньше текущей.
    
    \item Рассмотрим три последовательные вершины $\operatorname{prev}(cur)$, $cur$ и $\operatorname{next}(cur)$. 
    Если эти вершины образуют поворот по часовой стрелке, то вершина $cur$ является вогнутой, 
    и все инцидентные ей ребра в графе видимости являются незначащими согласно теореме~\ref{thm:minor_edge} (рис. \ref{fig:concave}). 
    Следовательно, такая вершина $cur$ может быть полностью исключена из рассмотрения в качестве кандидата на проведение ребер.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\linewidth]{images/2.png}
        \caption{Вогнутая часть препятствия}
        \label{fig:concave}
    \end{figure}
    
    \item Если же указанные вершины образуют поворот против часовой стрелки, то вершина $cur$ является выпуклой. 
    В этом случае при обработке вершины $cur$ все ребра, построенные в вершины, лежащие внутри сектора, 
    образованного лучом из $\operatorname{prev}(cur)$ через $cur$ и лучом из $\operatorname{next}(cur)$ через $cur$, 
    будут незначащими (рис. \ref{fig:convex}). Данное множество вершин может быть исключено из проверки видимости.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\linewidth]{images/1.png}
        \caption{Выпуклая часть препятствия}
        \label{fig:convex}
    \end{figure}
    
\end{enumerate}

В реализации последняя оптимизация может оказаться сложнее остальных.

Например, можно действовать следующим образом:
\begin{enumerate}
    \item Запускаем стандартный алгоритм Ли для источника, но заметающий луч совершает не полный оборот,
          а доходит до начала сектора, образованного лучами, описанными в пункте 2.
    \item Далее немного изменим алгоритм Ли:
        \begin{itemize}
            \item Луч $L$ устанавливается в направлении горизонтально влево (при условии, что применен п. 1).
            \item В статус аналогично вносятся все ребра препятствий, которые пересекает луч в этом начальном положении,
                  упорядоченные по расстоянию от источника.
            \item События обрабатываются в порядке убывания полярного угла.
        \end{itemize}
    \item Обработка продолжается до достижения другой границы сектора.
\end{enumerate}
В результате вершины, находящиеся внутри этого сектора, не обрабатываются, что позволяет существенно
сократить время работы алгоритма.

Можно заметить, что обработка вершин происходит независимо друг от друга,
так как для каждой вершины рассматриваются вершины только выше ее самой (те, у которых $y$-координата больше).
То есть подход, описанный выше, можно распараллелить:

Список отсортированных вершин можно обрабатывать параллельно. 
Для этого запустим несколько потоков, каждый из которых получит свою вершину.
Чтобы потоки не мешали друг другу, дадим им задания не все сразу, а порциями: 
сначала раздадим вершины всем потокам, ждем, пока они закончат, потом берем следующую группу вершин и повторяем процедуру.
Такой подход позволяет эффективно использовать все ядра процессора и значительно ускоряет работу алгоритма.

\section{Хранение графа}

В задачах, связанных с графами, важную роль играет выбор способа их хранения. 
Наиболее простым, но не самым оптимальным с точки зрения производительности подходом, 
является хранение для каждой вершины контейнера с инцидентными ей рёбрами или соседними вершинами. 
Такой подход часто используется в различных проектах и может выглядеть следующим образом:

\begin{lstlisting}[language=C++]
struct Vertex 
{
    std::set<Edge*> edges;
};

struct Edge 
{
    Vertex* a;
    Vertex* b;
};
\end{lstlisting}

Однако данный способ уступает по эффективности альтернативным решениям, 
предложенным далее (см. таблицу~\ref{tab:results}).



\section{Результаты тестирования производительности}

В качестве результатов сравним время работы наивного алгоритма и оптимизированного алгоритма Ли.

\subsection{Тестовые данные}

Тестирование проводилось на планарном графе, изображенном на рисунке~\ref{fig:test_graph}. Характеристики графа:
\begin{itemize}
    \item количество вершин: \(n = 6578\);
    \item количество ребер: \(m = 6559\).
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{images/3.png}
    \caption{Исходный планарный граф}
    \label{fig:test_graph}
\end{figure}

После применения алгоритма построения графа видимости количество ребер увеличилось до 12668. 
Результирующий граф видимости представлен на рисунке~\ref{fig:visibility_graph}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{images/4.png}
    \caption{Построенный граф видимости}
    \label{fig:visibility_graph}
\end{figure}

\subsection{Характеристики тестового стенда}

Тестирование проводилось на машине со следующими характеристиками:
\begin{itemize}
    \item процессор: AMD Ryzen 5 5600X 6-Core Processor;
    \item тактовая частота: базовая 2.2 ГГц, максимальная 4.65 ГГц;
    \item оперативная память: 32 ГБ;
    \item операционная система: Ubuntu 24.04.4 LTS.
\end{itemize}

\subsection{Результаты замеров времени}

В таблице~\ref{tab:results} представлены результаты замеров времени работы различных реализаций алгоритмов.

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Алгоритм} & \textbf{Время выполнения, с} \\
        \hline
        Наивный алгоритм (O(n²·m)) с плохим хранением графа & 33,164 \\
        \hline
        Наивный алгоритм (O(n²·m)) с хорошим хранением графа & 26,074 \\
        \hline
        Алгоритм Ли с оптимизациями и плохим хранением графа & 1,107 \\
        \hline
        Алгоритм Ли с оптимизациями и хорошим хранением графа & 0,963 \\
        \hline
        Алгоритм Ли с оптимизациями и распараллеливанием & 0,340 \\
        \hline
    \end{tabular}
    \caption{Сравнение времени работы алгоритмов}
    \label{tab:results}
\end{table}

Как видно из результатов, реализация с хорошим хранением графа работает быстрее, чем с плохим,
как для наивного алгоритма (26,074 с против 33,164 с), так и для оптимизированного алгоритма Ли (0,963 с против 1,107 с).
Плохая реализация хранения графа подразумевает хранение в каждой вершине сбалансированного дерева
инцидентных ребер и большое число указателей, что создает значительные накладные расходы при доступе к данным.

\section*{Заключение}

В результате проделанной работы удалось значительно ускорить алгоритм Ли для построения графа видимости.
Были реализованы и протестированы наивный алгоритм, оптимизированная версия алгоритма Ли, а также его параллельная модификация.
Эксперименты на сцене с 6578 вершинами показали, что оптимизированный алгоритм работает более чем в 25 раз быстрее наивного,
а распараллеливание на 12 потоков даёт дополнительное ускорение в 2.5 раза.

При этом хорошее хранение графа дает дополнительный прирост производительности по сравнению с плохим 
за счет меньших накладных расходов при доступе к данным.

Полученные результаты могут быть использованы в системах планирования пути, работающих в реальном времени,
а также в научных исследованиях, связанных с вычислительной геометрией.
\newpage

\begin{thebibliography}{99}

    \bibitem{ghosh87}
    Ghosh S.~K., Mount D.~M. An Output-Sensitive Algorithm for Computing Visibility Graphs //
    Proceedings of the 28th Annual Symposium on Foundations of Computer Science (FOCS'87). 
    -- IEEE, 1987. -- P. 11--19.

    \bibitem{nilsson69}
    Nilsson N.~J. A mobile automaton: An application of artificial intelligence techniques //
    Proceedings of the 1st International Joint Conference on Artificial Intelligence (IJCAI'69). 
    -- 1969. -- P. 509--520.

    \bibitem{lee78}
    Lee D.~T. Proximity and reachability in the plane : Ph.D. Thesis / University of Illinois 
    at Urbana-Champaign. -- 1978.
    \bibitem{coleman2012visibility}
    D.~Coleman.
    \newblock Lee's O(n\string^2 log n) visibility graph algorithm: Implementation and analysis.
    \newblock Technical report, University of Colorado at Boulder, 2012.

    \bibitem{nash07theta}
    A.~Nash, K.~Daniel, S.~Koenig, and A.~Felner.
    \newblock Theta*: Any-angle path planning on grids.
    \newblock In {\em Proc. of the AAAI Conference on Artificial Intelligence}, 2007.

    \bibitem{nash10lazy}
    A.~Nash, S.~Koenig, and C.~Tovey.
    \newblock Lazy Theta*: Any-angle path planning and path length analysis in 3D.
    \newblock In {\em Proc. of the AAAI Conference on Artificial Intelligence}, 2010.

    \bibitem{harabor16anya}
    D.~Harabor and A.~Grastien.
    \newblock An optimal any-angle pathfinding algorithm.
    \newblock In {\em Proc. of the International Conference on Automated Planning and
      Scheduling (ICAPS)}, 2016.

    \bibitem{orourke98vertexedge}
    J.~O'Rourke and I.~Streinu.
    \newblock The vertex-edge visibility graph of a polygon.
    \newblock {\em Computational Geometry: Theory and Applications}, 10(2):105–120, 1998.
\end{thebibliography}
\end{document}
