\documentclass{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}


\usepackage{amsmath,amssymb,amsthm}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{authblk}
\usepackage{url}

\theoremstyle{definition}
\newtheorem{definition}{Определение}
\newtheorem{theorem}{Теорема}

\begin{document}

\title{Оптимизация алгоритма построения графа видимости}
\date{\today}

%\issue{2026}{1}{edu}
%\setcounter{page}{1}
%\journalsection{informatics}
%\articletype{Научная статья}

\author[1]{Баринов М. А.}
\author[2]{Павлов Д. А.}
\affil[1]{СПбГЭТУ «ЛЭТИ», факультет компьютерных технологий и информатики}
\affil[2]{СПбГЭТУ «ЛЭТИ», факультет компьютерных технологий и информатики}

\maketitle

\begin{abstract}
  \end{abstract}

\section{Введение}

Планирование оптимальной траектории для точечного агента на плоскости с полигональными препятствиями
является фундаментальной задачей вычислительной геометрии и робототехники.
Её практическая значимость охватывает такие области, как навигация мобильных роботов (в том числе беспилотных автомобилей),
анализ зон видимости в геоинформационных системах, компьютерное зрение и разработка компьютерных игр.
Суть задачи состоит в нахождении траектории минимальной евклидовой длины, соединяющей заданные начальную
и конечную точки и не пересекающей внутренности непересекающихся многоугольных препятствий.

Классическим подходом к решению этой задачи является построение \textit{графа видимости} вершин,
в котором вершины препятствий соединяются ребрами, если между ними есть «видимость» по прямой.
Поиск кратчайшего пути в таком графе гарантирует оптимальность решения.
Впервые понятие графа видимости было введено Нильсоном в 1968 году в контексте 
решения задачи планирования пути для мобильного робота ``Shakey''~\cite{nilsson69}.
Им же было доказано, что кратчайший путь между двумя точками среди многоугольных 
препятствий обязан проходить через их вершины.

В 1979 году Ли предложил эффективный алгоритм построения графа
видимости со сложностью $O(n^2 \log n)$, где $n$ --- общее количество
вершин препятствий~\cite{lee78,coleman2012visibility}.
Этот алгоритм использовал метод заметающего луча.
Алгоритм, предложенный позднее Гошем и Маунтом~\cite{ghosh87},
имеет оценку времени работы $O(E + n \log n)$, где $E$ — число ребер в итоговом графе.
Ключевая идея алгоритма заключается в
использовании триангуляции пространства и особой структуры данных —
«воронок» (funnels), что позволяет добавлять новые вершины и ребра в граф
по одной, тратя время пропорционально только реально появляющимся связям.
Данная идея сложна в реализации, и публично доступных реализаций не известно.
Ещё два метода с оценками сложности $O(n^2)$ и $O(E \log n)$, были предложены
в~\cite{OvermarsWelzl}; их публично доступных реализаций также не известно.
Также следует отметить, что в настоящее время интерес представляют
алгоритмы, использующие возможности современных многоядерных
процессоров. В настоящей работе рассматривается модификация алгоритма
Ли с параллельной обработкой данных.

Наряду с классической задачей построения графа видимости на карте с
полигональными препятствиями известна задача построения графа
видимости на прямоугольной сетке вершин, с проведением рёбер под
произвольными углами (any-angle path
planning)~\cite{nash07theta,nash10lazy,harabor16anya}, Вот некоторые
из них:

\begin{itemize}
    \item \textbf{Theta* и Lazy Theta*} --- модификации A*, использующие проверку 
    прямой видимости между вершинами для спрямления пути;
    \item \textbf{ANYA} --- находит оптимальные пути под любым углом, ограничивая пространство поиска узкими путями 
        (путь, где каждое изменение направления пути «обвивается» вокруг какого-либо препятствия); 
        рассматривая интервал точек как узел, а не как отдельную точку. 
        Этот алгоритм ограничен двумерными сетками.
    \item \textbf{Field D*} --- алгоритм динамического поиска пути на основе D*, 
        использующий интерполяцию при каждом расширении вершины для нахождения почти оптимальных путей через регулярные, 
        неравномерные сетки стоимости.
\end{itemize}

Стоит отметить, что помимо прикладных алгоритмов поиска пути, в литературе активно исследуются
различные теоретические модификации графов видимости, расширяющие представление о структуре пространства.
Так, в работе О'Рурка и Стрейну \cite{orourke98vertexedge} был предложен и проанализирован
\textbf{вершинно-рёберный граф видимости}, в котором учитываются не только связи между вершинами,
но и видимость вершин до ребер препятствий. Авторы показали, что такая структура содержит больше
информации о геометрии сцены, позволяя, например, однозначно определять тип вершин и восстанавливать
деревья кратчайших путей. Хотя данная работа носит преимущественно теоретический характер,
подобные результаты могут служить основой для разработки более информированных методов планирования маршрутов.

% С развитием многоядерных процессоров в 2000-х годах акцент сместился в сторону 
% параллельных реализаций классических алгоритмов.

\section{Формальная постановка задачи}
\label{sec:problem}

Пусть заданы:
\begin{enumerate}[label=\textbf{\arabic*.}]
    \item \textbf{Пространство:} Евклидова плоскость $\mathbb{R}^2$.
    \item \textbf{Начальная и конечная точки:} $S, T \in \mathbb{R}^2$, $S \neq T$.
    \item \textbf{Множество препятствий:} $\mathcal{P} = \{P_1, P_2, \dots, P_k\}$ --- конечный набор простых многоугольников, таких что:
    \begin{itemize}
        \item $\forall i \neq j: P_i \cap P_j = \varnothing$ (многоугольники не пересекаются);
        \item $S, T \notin \bigcup_{i=1}^k \operatorname{int}(P_i)$, где $\operatorname{int}(P_i)$ --- внутренность многоугольника $P_i$.
    \end{itemize}
\end{enumerate}

\begin{definition}[Допустимая траектория]
\textbf{Допустимой траекторией} называется непрерывное отображение $\phi: [0, 1] \to \mathbb{R}^2$, удовлетворяющее условиям:
\begin{itemize}
    \item $\phi(0) = S$, $\phi(1) = T$;
    \item $\forall t \in (0, 1): \phi(t) \notin \bigcup_{i=1}^k \operatorname{int}(P_i)$.
\end{itemize}
Траектория может касаться границ препятствий $\partial P_i$.
\end{definition}

\begin{definition}[Длина траектории]
Для допустимой траектории $\phi$ её \textbf{евклидова длина} определяется как:
\[
L(\phi) = \sup \left\{ \sum_{i=1}^{n} \|\phi(t_i) - \phi(t_{i-1})\| \ \middle| \ 0 = t_0 < t_1 < \dots < t_n = 1 \right\},
\]
где $\| \cdot \|$ --- евклидова норма в $\mathbb{R}^2$.
\end{definition}

\begin{definition}[Оптимальная траектория]
Допустимая траектория $\phi^*$ называется \textbf{оптимальной} (кратчайшей), если
\[
L(\phi^*) = \min \{ L(\phi) \mid \phi \text{ --- допустимая траектория} \}.
\]
\end{definition}

\section{Граф видимости}
\label{sec:visibility-graph}

Ключевым инструментом решения задачи является дискретизация пространства с помощью графа видимости.

\subsection{Построение графа}

\begin{definition}[Множество вершин]
Множество вершин графа видимости есть объединение всех вершин препятствий и начальной с конечной точками:
\[
V = \{S, T\} \cup \bigcup_{i=1}^k V(P_i),
\]
где $V(P_i)$ --- множество вершин многоугольника $P_i$.
\end{definition}

\begin{definition}[Ребро видимости]
Для двух различных вершин $u, v \in V$ отрезок $[u, v]$ называется \textbf{видимым}, если
\[
[u, v] \cap \left( \bigcup_{i=1}^k \operatorname{int}(P_i) \right) = \varnothing,
\]
где $[u, v] = \{\lambda u + (1-\lambda)v \mid \lambda \in [0, 1]\}$ --- замкнутый отрезок.
\end{definition}

\begin{definition}[Граф видимости]
\textbf{Графом видимости} называется взвешенный неориентированный граф $G = (V, E, w)$, где:
\begin{itemize}
    \item $V$ --- множество вершин, определённое выше;
    \item $E \subseteq V \times V$ --- множество рёбер, такое что $(u, v) \in E$ тогда и только тогда, когда $u \neq v$ и отрезок $[u, v]$ видим;
    \item $w: E \to \mathbb{R}^+$ --- функция весов, заданная евклидовым расстоянием: $w(u, v) = \|u - v\|_2$.
\end{itemize}
\end{definition}

\subsection{Основная теорема}

Следующая теорема устанавливает фундаментальную связь между исходной непрерывной задачей и задачей поиска пути в графе.
Она была доказана Нильсоном~\cite{nilsson69} и позднее уточнена Ли~\cite{lee78}.

\begin{theorem}[Основное свойство графа видимости]
Пусть $\phi^*: [0,1] \to \mathbb{R}^2$ --- оптимальная траектория в исходной задаче, а $G = (V, E, w)$ --- соответствующий граф видимости. Тогда:
\begin{enumerate}[label=\textbf{(\arabic*)}]
    \item \textbf{Существование дискретного пути:} Существует путь $p = (v_0, v_1, \dots, v_m)$ в графе $G$, где $v_0 = S$, $v_m = T$, такой что
    \[
    L(\phi^*) = \sum_{j=0}^{m-1} \|v_{j+1} - v_j\|_2 = \sum_{(u,v) \in p} w(u,v).
    \]
    
    \item \textbf{Структура оптимальной траектории:} Оптимальная траектория $\phi^*$ является ломаной линией,
        вершины которой принадлежат множеству $V$: $\{v_0, v_1, \dots, v_m\} \subseteq V$.
    
    \item \textbf{Эквивалентность задач:} Кратчайший путь в исходной задаче соответствует кратчайшему пути в графе $G$:
    \[
    \min_{\phi \ \text{допустимая}} L(\phi) = \min_{p \ \text{путь в} \ G \ \text{из} \ S \ \text{в} \ T} \sum_{(u,v) \in p} w(u,v).
    \]
\end{enumerate}
\end{theorem}

\subsection{Алгоритмическое следствие}

На основании теоремы поиск кратчайшей траектории в непрерывной области сводится к следующей двухэтапной процедуре:

\begin{enumerate}
    \item \textbf{Построение графа видимости} $G = (V, E, w)$ для заданных препятствий $\mathcal{P}$ и точек $S$, $T$.
    \item \textbf{Поиск кратчайшего пути} в графе $G$ из вершины $S$ в вершину $T$ с использованием стандартных алгоритмов теории графов, 
        таких как алгоритм Дейкстры или A*.
\end{enumerate}

Сложность решения в первую очередь определяется построением графа, которое в наивной реализации требует $O(|V|^2)$ проверок видимости
для каждой пары вершин, где $|V| = 2 + \sum_{i=1}^k |V(P_i)|$. 

\section{Построение графа видимости}
\label{sec:construction}
Без ограничения общности примем, что рёбра всех препятствий направлены так, что внутренняя часть каждого препятствия находится слева от направления обхода. (Обход против часовой стрелки.)

\subsection{Наивный подход}

Наивная реализация процедуры построения графа видимости $G=(V,E,w)$ основана на полном переборе всех возможных пар вершин
и проверке видимости соответствующего отрезка.

\begin{enumerate}[label=\textbf{Шаг \arabic*.}]
    \item Формируется множество вершин $V = \{S, T\} \cup \bigcup_{i=1}^k V(P_i)$.
    \item Для каждой упорядоченной пары вершин $(u, v) \in V \times V$, где $u \neq v$, проверяется условие видимости отрезка $[u, v]$.
    \item Если отрезок $[u, v]$ видим, то в множество рёбер $E$ добавляется неориентированное ребро $(u, v)$ с весом $w(u,v) = \|u - v\|_2$.
\end{enumerate}

Сложность данного подхода определяется количеством пар вершин, равным $O(|V|^2)$,
и стоимостью проверки видимости одного отрезка, которая в наивной реализации составляет $O(n)$,
где $n$ --- общее количество рёбер во всех препятствиях. Таким образом, итоговая сложность составляет $O(|V|^2 \cdot n)$, 
что делает метод неэффективным для сцен со сложной геометрией.

\subsection{Оптимальный алгоритм на основе заметающего луча (Алгоритм Ли)}

Для эффективного построения графа видимости применяется алгоритм, предложенный Ли,
сложность которого составляет $O(|V|^2 \log |V|)$ в худшем случае.
Алгоритм последовательно для каждой вершины $s \in V$ (называемой \emph{источником}) определяет все другие видимые из неё вершины.

Идея метода: будем вращать луч вокруг источника $s$ и отслеживать, какие рёбра препятствий пересекает этот луч в данный момент. 
Ближайшее к $s$ пересечение определяет, закрыта ли очередная вершина каким-либо препятствием

\begin{definition}[Заметающий луч]\label{def:processing_ray}
Для источника $s$ и текущей вершины $v$ \textbf{заметающим лучом} $L(s, v)$ называется луч с началом в $s$, проходящий через $v$.
\end{definition}

\begin{definition}[Статус луча]\label{def:ray_status}
\textbf{Статусом} на текущем угле обхода называется упорядоченное множество (например, сбалансированное дерево) рёбер препятствий,
которые пересекает заметающий луч $L(s, v)$. Рёбра упорядочены по возрастанию расстояния от точки $s$ до точки пересечения с лучом.
\end{definition}

\subsubsection{Основные этапы для одного источника}

Алгоритм для фиксированного источника $s$ состоит из следующих этапов.

\begin{enumerate}[label=\textbf{Этап \arabic*.}]
    \item \textbf{Подготовка и сортировка.}
    \begin{itemize}
        \item Все вершины $v \in V \setminus \{s\}$ проецируются на полярную систему координат с полюсом в $s$.
        \item Вершины сортируются в порядке возрастания полярного угла $\theta(s, v)$. При равенстве углов приоритет отдаётся вершине, ближайшей к $s$.
        \item Для каждого ребра $e$ препятствия, \emph{видимого} из $s$ (т.е. хотя бы один конец $e$ видим из $s$),
            определяются события: ``начало отрезка'' и ``конец отрезка'', 
            соответствующие моментам, когда вращающийся луч $L$ совпадает с направлением на концы $e$.
    \end{itemize}

    \item \textbf{Инициализация.}
    \begin{itemize}
        \item Луч $L$ устанавливается в направлении $\theta = 0$ (например, горизонтально вправо).
        \item В статус заносятся все рёбра препятствий, которые пересекает луч в этом начальном положении, упорядоченные по расстоянию от $s$.
    \end{itemize}

    \item \textbf{Последовательная обработка событий.}
    \begin{itemize}
        \item События обрабатываются в порядке возрастания полярного угла.
        \item При наступлении события ``вершина $v$'':
        \begin{itemize}
            \item Если статус пуст, то вершина $v$ \emph{видима} из $s$, и ребро $(s, v)$ добавляется в граф.
            \item Если статус не пуст, то $v$ видима только если отрезок $[s, v]$ не пересекается с ближайшим к $s$ ребром из статуса
                (т.е. $v$ находится ближе к $s$, чем точка пересечения луча $L(s, v)$ с этим ребром).
        \end{itemize}
        \item При наступлении события ``начало отрезка $e$'': ребро $e$ добавляется в статус,
            если при его рассмотрении выполняется условие обхода \emph{против часовой стрелки} для точек ($s$, начало $e$, конец $e$).
        \item При наступлении события ``конец отрезка $e$'': ребро $e$ удаляется из статуса,
            если при его рассмотрении выполняется условие обхода \emph{по часовой стрелке} для точек ($s$, конец $e$, начало $e$).
    \end{itemize}
\end{enumerate}


После завершения обработки всех событий для источника $s$ мы получаем все видимые из $s$ вершины.
Повторяя процедуру для каждого $s \in V$, строим полный граф видимости.
Использование сбалансированных деревьев для хранения статуса обеспечивает сложность $O(\log |V|)$ на операцию вставки или удаления ребра,
что приводит к общей сложности $O(|V|^2 \log |V|)$ для построения всего графа.

\section{Оптимизация}

Несмотря на эффективность алгоритма Ли, построенный граф видимости содержит значительное число ребер,
которые заведомо не могут принадлежать ни одному кратчайшему пути. Выявление и исключение таких ребер
на этапе построения позволяет сократить как время построения графа, так и время последующего поиска пути.

\begin{definition}[Локальная конфигурация вершины]
Для вершины $cur$, принадлежащей некоторому препятствию $P_i$, определим ее \textbf{соседей} вдоль границы этого препятствия. 
Пусть $\operatorname{prev}(cur)$ и $\operatorname{next}(cur)$ --- вершины, непосредственно предшествующая и следующая за $cur$ 
при обходе контура многоугольника $P_i$. Для начальной и конечной точек $S, T$, 
не лежащих на границах препятствий, множество соседей считается пустым.
\end{definition}

\begin{theorem}[Критерий незначащего ребра]
\label{thm:minor_edge}
Пусть $u, v \in V$ --- две различные вершины графа видимости, и пусть отрезок $[u, v]$ является видимым. 
Обозначим через $l_{uv}$ прямую, проходящую через точки $u$ и $v$. 
Ребро $(u, v)$ называется \textbf{незначащим} (\emph{minor edge}), если для каждой из этих вершин выполняются следующие условия:
\begin{itemize}
    \item вершина принадлежит некоторому препятствию;
    \item ее соседи вдоль границы этого препятствия существуют;
    \item эти соседи лежат по разные стороны от прямой $l_{uv}$.
\end{itemize}
Такое ребро не может принадлежать ни одному кратчайшему пути в графе видимости и может быть исключено из рассмотрения
(рис. \ref{fig:minor_edge}, красным цветом выделено такое ребро, а зеленым допустимые).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{images/5.png}
    \caption{Незначащее ребро}
    \label{fig:minor_edge}
\end{figure}


\end{theorem}

А также:

\begin{enumerate}
    \item Можно заметить следующее: 
    если мы имеем две вершины $u$ и $v$ такие, что первая из них расположена ниже второй 
    (то есть ее $y$-координата меньше), тогда при обработке вершины $v$ ребро $(u,v)$ 
    либо будет проведено, если оно допустимо, либо не будет. Следовательно, можно не рассматривать вершины, 
    у которых $y$-координата меньше текущей.
    
    \item Рассмотрим три последовательные вершины $\operatorname{prev}(cur)$, $cur$ и $\operatorname{next}(cur)$. 
    Если эти вершины образуют поворот по часовой стрелке, то вершина $cur$ является вогнутой, 
    и все инцидентные ей ребра в графе видимости являются незначащими согласно теореме~\ref{thm:minor_edge} (рис. \ref{fig:concave}). 
    Следовательно, такая вершина $cur$ может быть полностью исключена из рассмотрения в качестве кандидата на проведение ребер.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\linewidth]{images/2.png}
        \caption{Вогнутая часть препятствия}
        \label{fig:concave}
    \end{figure}
    
    \item Если же указанные вершины образуют поворот против часовой стрелки, то вершина $cur$ является выпуклой. 
    В этом случае при обработке вершины $cur$ все ребра, построенные в вершины, лежащие внутри сектора, 
    образованного лучом из $\operatorname{prev}(cur)$ через $cur$ и лучом из $\operatorname{next}(cur)$ через $cur$, 
    будут незначащими (рис. \ref{fig:convex}). Данное множество вершин может быть исключено из проверки видимости.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\linewidth]{images/1.png}
        \caption{Выпуклая часть препятствия}
        \label{fig:convex}
    \end{figure}
    
\end{enumerate}

В реализации последняя оптимизация может оказаться сложнее остальных.

Например, можно действовать следующим образом:
\begin{enumerate}
    \item Запускаем стандартный алгоритм Ли для источника, но заметающий луч совершает не полный оборот,
          а доходит до начала сектора, образованного лучами, описанными в пункте 2.
    \item Далее немного изменим алгоритм Ли:
        \begin{itemize}
            \item Луч $L$ устанавливается в направлении горизонтально влево (при условии, что применен п. 1).
            \item В статус аналогично вносятся все ребра препятствий, которые пересекает луч в этом начальном положении,
                  упорядоченные по расстоянию от источника.
            \item События обрабатываются в порядке убывания полярного угла.
        \end{itemize}
    \item Обработка продолжается до достижения другой границы сектора.
\end{enumerate}
В результате вершины, находящиеся внутри этого сектора, не обрабатываются, что позволяет существенно
сократить время работы алгоритма.

Можно заметить, что обработка вершин происходит независимо друг от друга,
так как для каждой вершины рассматриваются вершины только выше ее самой (те, у которых $y$-координата больше).
То есть подход, описанный выше, можно распараллелить:

Список отсортированных вершин можно обрабатывать параллельно. 
Для этого запустим несколько потоков, каждый из которых получит свою вершину.
Чтобы потоки не мешали друг другу, дадим им задания не все сразу, а порциями: 
сначала раздадим вершины всем потокам, ждем, пока они закончат, потом берем следующую группу вершин и повторяем процедуру.
Такой подход позволяет эффективно использовать все ядра процессора и значительно ускоряет работу алгоритма.

\section{Хранение графа}

В задачах, связанных с графами, важную роль играет выбор способа их хранения.
В то время как с теоретической точки зрения очевидным выбором является
хранение списков смежности при каждой вершине графа, реализация самой
схемы представления этих списков смежности в оперативной памяти
является важной деталью реализации.

\subsection{Наивная схема хранения}
Наиболее простым, но не самым оптимальным с точки зрения производительности подходом, 
является хранение для каждой вершины контейнера с инцидентными ей рёбрами или соседними вершинами. 
Наивная реализация такого подхода может выглядеть следующим образом:

\begin{lstlisting}[language=C++]
struct Vertex 
{
    std::set<edge_id> edges;
};

struct Edge 
{
    vertex_id a;
    vertex_id b;
};
\end{lstlisting}

\subsection{Реализация в Boost Graph Library (BGL)}

ОБщедоступная библиотека BGL имеет шаблонизированный класс \texttt{adjacency\_list}~\cite{BGLadj}, предоставляющий разные варианты хранения списка вершин и списков рёбер:
\texttt{vector}, \texttt{list}, \texttt{slist} (односвязный список), \texttt{set}, \texttt{multiset}, \texttt{unordered\_set}. Быстродействие
различных операций с графом зависит от того, какие контейнеры используются. Также существует гибкая схема (т. н. «custom storage»), в рамках
которой программист может определить свои контейтеры для представления списков смежности.

При большом количестве вершин возникает проблема фрагментации памяти,
из-за большого количества небольших фрагментов памяти, выделенных в
куче. Фрагментация памяти приводит к возросшему количеству «промахов»
кеша процессора и к общему снижению производительности
программы. Для борьбы с фрагментацией теоретически можно использовать
вышеупомянутую возможность создания специальных контейнеров, однако
публично доступные примеры таких контейнеров неизвестны. Альтернативой
в BGL является «компрессированная» форма представления графа в памяти
— Compressed Sparse Row, CSR~\cite{BGLCSR}, ограничением которой является
невозможность модификации графа.

\subsection{LogGraph}

Ещё одной «компрессированной» формой представления графа в памяти
является LogGraph~\cite{LogGraph} — достаточно сложная схема,
близкая к оптимальной по степени компрессии и имеющая сравнительно
невысокие накладные расходы на декомпрессию. Как и CSR, LogGraph
предназначена для хранения в оперативной памяти статичных, не
модифицируемых графов.

\subsection{Реализации в LEMON и Indigo}

LEMON (Library for Efficient Modeling and Optimization in Networks)
--- библиотека для работы с графами, в настоящее время не развиваемая
(разработка происходила в 2004--2014 гг.). Это наиболее ранняя,
найденная авторами (и одна из немногих) реализация хранения списков
смежности всех вершин в едином контейнере, для решения проблемы
фрагментации памяти (при этом, в отличие от вышеупомянутой схемы CSR,
возможна модификация графа).
Данная реализация доступна в виде исходного кода и не документирована.

Аналогичное решение применено в Indigo — библиотеке для работы с
молекулярными структурами~\cite{Indigo,IndigoGithub}. Односвязные списки смежности всех вершин
графа хранятся в едином контейнере под названием «пул» (pool), который
в свою очередь реализован на массиве. Данная реализация также доступна в
виде исходного кода и не документирована.

В настоящей работе наряду с «наивной» схемой хранения список смежности
реализована схема хранения, аналогичная реализациям в LEMON и Indigo.
Эта схема не претендует, подобно CSR и LogGraph, на оптимальность
по объёму памяти, но тем не менее устраняет проблему фрагментации,
при этом позволяя добавление и удаление вершин и рёбер.

\section{Результаты тестирования производительности}

В качестве результатов сравним время работы наивного алгоритма и оптимизированного алгоритма Ли.

\subsection{Тестовые данные}

Тестирование проводилось на планарном графе, изображенном на рисунке~\ref{fig:test_graph}. Характеристики графа:
количество вершин \(n = 6578\); количество ребер \(m = 6559\).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{images/3.png}
    \caption{Исходный планарный граф}
    \label{fig:test_graph}
\end{figure}

После применения алгоритма построения графа видимости количество ребер увеличилось до 12668. 
Результирующий граф видимости представлен на рисунке~\ref{fig:visibility_graph}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{images/4.png}
    \caption{Построенный граф видимости}
    \label{fig:visibility_graph}
\end{figure}

\subsection{Характеристики тестового стенда}

Тестирование проводилось на машине со следующими характеристиками:
\begin{itemize}
    \item процессор: AMD Ryzen 5 5600X 6-Core Processor;
    \item тактовая частота: базовая 2.2 ГГц, максимальная 4.65 ГГц;
    \item оперативная память: 32 ГБ;
    \item операционная система: Ubuntu 24.04.4 LTS.
\end{itemize}

\subsection{Результаты замеров времени}

В таблице~\ref{tab:results} представлены результаты замеров времени работы различных реализаций алгоритмов.

\begin{table}[h!]
    \centering
    \begin{tabular}{|p{9cm}|p{2.5cm}|}
        \hline
        \textbf{Алгоритм} & \textbf{Время выполнения, с} \\
        \hline
        Наивный алгоритм (O(n²·m)) с фрагментированным представлением графа & 33.164 \\
        \hline
        Наивный алгоритм (O(n²·m)) с дефрагментированным представлением графа  & 26.074 \\
        \hline
        Алгоритм Ли с оптимизациями и фрагментированным представлением графа & 1.107 \\
        \hline
        Алгоритм Ли с оптимизациями и дефрагментированным представлением графа & 0.963 \\
        \hline
        Алгоритм Ли с оптимизациями, дефрагментированным представлением графа и распараллеливанием & 0.340 \\
        \hline
    \end{tabular}
    \caption{Сравнение времени работы алгоритмов}
    \label{tab:results}
\end{table}

Как видно из результатов, реализация с дефрагментированным представлением графа работает быстрее, чем с фрагментированным,
как для наивного алгоритма (26.074 с против 33.164 с), так и для оптимизированного алгоритма Ли (0.963 с против 1.107 с).

\section*{Заключение}

В результате проделанной работы удалось значительно ускорить алгоритм Ли для построения графа видимости.
Были реализованы и протестированы наивный алгоритм, оптимизированная версия алгоритма Ли, а также его параллельная модификация.
Эксперименты на сцене с 6578 вершинами показали, что оптимизированный алгоритм работает более чем в 25 раз быстрее наивного,
а распараллеливание на 12 потоков даёт дополнительное ускорение в 2.5 раза.

При этом дефрагментация представления графа в оперативной памяти дополнительный прирост производительности 
за счет меньших накладных расходов при доступе к данным.

Полученные результаты могут быть использованы в системах планирования пути, работающих в реальном времени,
а также в научных исследованиях, связанных с вычислительной геометрией.
\newpage

\begin{thebibliography}{99}

    \bibitem{ghosh87}
    Ghosh S.~K., Mount D.~M. An Output-Sensitive Algorithm for Computing Visibility Graphs //
    Proceedings of the 28th Annual Symposium on Foundations of Computer Science (FOCS'87). 
    -- IEEE, 1987. -- P. 11--19.

  \bibitem{OvermarsWelzl}
    Mark H. Overmars, Emo Welzl. New Methods for Computing Visibility Graphs //
    Proceedings of the fourth annual symposium on Computational geometry (SCG'88).
    -- 1988. -- P. 164–171
    
    \bibitem{nilsson69}
    Nilsson N.~J. A mobile automaton: An application of artificial intelligence techniques //
    Proceedings of the 1st International Joint Conference on Artificial Intelligence (IJCAI'69). 
    -- 1969. -- P. 509--520.

    \bibitem{lee78}
    Lee D.~T. Proximity and reachability in the plane : Ph.D. Thesis / University of Illinois 
    at Urbana-Champaign. -- 1978.
    
    \bibitem{coleman2012visibility}
    D.~Coleman.
    \newblock Lee's O(n\string^2 log n) visibility graph algorithm: Implementation and analysis.
    \newblock Technical report, University of Colorado at Boulder, 2012.

    \bibitem{nash07theta}
    A.~Nash, K.~Daniel, S.~Koenig, and A.~Felner.
    \newblock Theta*: Any-angle path planning on grids.
    \newblock In {\em Proc. of the AAAI Conference on Artificial Intelligence}, 2007.

    \bibitem{nash10lazy}
    A.~Nash, S.~Koenig, and C.~Tovey.
    \newblock Lazy Theta*: Any-angle path planning and path length analysis in 3D.
    \newblock In {\em Proc. of the AAAI Conference on Artificial Intelligence}, 2010.

    \bibitem{harabor16anya}
    D.~Harabor and A.~Grastien.
    \newblock An optimal any-angle pathfinding algorithm.
    \newblock In {\em Proc. of the International Conference on Automated Planning and
      Scheduling (ICAPS)}, 2016.

    \bibitem{orourke98vertexedge}
    J.~O'Rourke and I.~Streinu.
    \newblock The vertex-edge visibility graph of a polygon.
    \newblock {\em Computational Geometry: Theory and Applications}, 10(2):105–120, 1998.

  \bibitem{BGLadj}
    \url{https://www.boost.org/latest/libs/graph/doc/using_adjacency_list.html}
  \bibitem{BGLCSR}
    \url{https://www.boost.org/latest/libs/graph/doc/compressed_sparse_row.html}

  \bibitem{Indigo}
    D. Pavlov, M. Rybalkin, B. Karulin, M. Kozhevnikov, A. Savelyev, A. Churinov. Indigo: universal cheminformatics API //
    J Cheminform 3 (Suppl 1), P4 (2011). \url{https://doi.org/10.1186/1758-2946-3-S1-P4}

  \bibitem{IndigoGithub}
    \url{https://github.com/epam/Indigo}

  \bibitem{LogGraph} Maciej Besta, Dimitri Stanojevic, Tijana Zivic,
    Jagpreet Singh, Maurice Hoerold, Torsten Hoefler.  Log(graph): a
    near-optimal high-performance graph representation // Proceedings
    of the 27th International Conference on Parallel Architectures and
    Compilation Techniques (2018).
    \url{https://doi.org/10.1145/3243176.3243198}
    
\end{thebibliography}
\end{document}
