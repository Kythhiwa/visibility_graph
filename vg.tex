\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{graphicx}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}

\geometry{top=2.5cm,bottom=2.5cm,left=2.5cm,right=2.5cm}

\theoremstyle{definition}
\newtheorem{definition}{Определение}
\newtheorem{theorem}{Теорема}

\begin{document}

\begin{titlepage}
    \begin{center}
        \textsc{Санкт-Петербургский государственный электротехнический университет «ЛЭТИ» им. В. И. Ульянова (Ленина)}\\[0.5cm]
        \textsc{Факультет компьютерных технологий и информатики}\\[2.5cm]
        
        
        \textbf{\LARGE ГРАФ ВИДИМОСТИ}\\
        
        \begin{flushright}
            \textbf{Работу выполнил:}\\
            Студент 3 курса\\
            Баринов Максим Алексеевич\\[0.5cm]
            \textbf{Научный руководитель:}\\
            Павлов Дмитрий Алексеевич
        \end{flushright}
        
        \vfill
        
        {\large Санкт-Петербург, \the\year}
    \end{center}
\end{titlepage}


\section{Введение}

Планирование оптимальной траектории для точечного агента на плоскости с полигональными препятствиями
является фундаментальной задачей вычислительной геометрии и робототехники.
Её практическая значимость охватывает такие области, как навигация мобильных роботов,
анализ зон видимости в геоинформационных системах, компьютерное зрение и разработка компьютерных игр.
Суть задачи состоит в нахождении траектории минимальной евклидовой длины, соединяющей заданные начальную
и конечную точки и не пересекающей внутренности непересекающихся многоугольных препятствий.
\subsection*{Историческая справка}

Задача поиска кратчайшего пути в среде с препятствиями имеет богатую историю. 
Впервые понятие графа видимости было введено Нильсоном в 1968 году в контексте 
решения задачи планирования пути для мобильного робота Shakey~\cite{nilsson69}. 
Им же было доказано, что кратчайший путь между двумя точками среди многоугольных 
препятствий обязан проходить через их вершины.

В 1979 году Ли предложил первый эффективный алгоритм построения графа видимости 
со сложностью $O(n^2 \log n)$~\cite{lee78}. Этот алгоритм использовал метод 
заметающего луча и стал основополагающим для дальнейших исследований.

С развитием многоядерных процессоров в 2000-х годах акцент сместился в сторону 
параллельных реализаций классических алгоритмов.

\section{Формальная постановка задачи}
\label{sec:problem}

Пусть заданы:
\begin{enumerate}[label=\textbf{\arabic*.}]
    \item \textbf{Пространство:} Евклидова плоскость $\mathbb{R}^2$.
    \item \textbf{Начальная и конечная точки:} $S, T \in \mathbb{R}^2$, $S \neq T$.
    \item \textbf{Множество препятствий:} $\mathcal{P} = \{P_1, P_2, \dots, P_k\}$ --- конечный набор простых многоугольников, таких что:
    \begin{itemize}
        \item $\forall i \neq j: P_i \cap P_j = \varnothing$ (многоугольники не пересекаются);
        \item $S, T \notin \bigcup_{i=1}^k \operatorname{int}(P_i)$, где $\operatorname{int}(P_i)$ --- внутренность многоугольника $P_i$.
    \end{itemize}
\end{enumerate}

\begin{definition}[Допустимая траектория]
\textbf{Допустимой траекторией} называется непрерывное отображение $\phi: [0, 1] \to \mathbb{R}^2$, удовлетворяющее условиям:
\begin{itemize}
    \item $\phi(0) = S$, $\phi(1) = T$;
    \item $\forall t \in (0, 1): \phi(t) \notin \bigcup_{i=1}^k \operatorname{int}(P_i)$.
\end{itemize}
Траектория может касаться границ препятствий $\partial P_i$.
\end{definition}

\begin{definition}[Длина траектории]
Для допустимой траектории $\phi$ её \textbf{евклидова длина} определяется как:
\[
L(\phi) = \sup \left\{ \sum_{i=1}^{n} \|\phi(t_i) - \phi(t_{i-1})\| \ \middle| \ 0 = t_0 < t_1 < \dots < t_n = 1 \right\},
\]
где $\| \cdot \|$ --- евклидова норма в $\mathbb{R}^2$.
\end{definition}

\begin{definition}[Оптимальная траектория]
Допустимая траектория $\phi^*$ называется \textbf{оптимальной} (кратчайшей), если
\[
L(\phi^*) = \min \{ L(\phi) \mid \phi \text{ --- допустимая траектория} \}.
\]
\end{definition}

\section{Граф видимости}
\label{sec:visibility-graph}

Ключевым инструментом решения задачи является дискретизация пространства с помощью графа видимости.

\subsection{Построение графа}

\begin{definition}[Множество вершин]
Множество вершин графа видимости есть объединение всех вершин препятствий и начальной с конечной точками:
\[
V = \{S, T\} \cup \bigcup_{i=1}^k V(P_i),
\]
где $V(P_i)$ --- множество вершин многоугольника $P_i$.
\end{definition}

\begin{definition}[Ребро видимости]
Для двух различных вершин $u, v \in V$ отрезок $[u, v]$ называется \textbf{видимым}, если
\[
[u, v] \cap \left( \bigcup_{i=1}^k \operatorname{int}(P_i) \right) = \varnothing,
\]
где $[u, v] = \{\lambda u + (1-\lambda)v \mid \lambda \in [0, 1]\}$ --- замкнутый отрезок.
\end{definition}

\begin{definition}[Граф видимости]
\textbf{Графом видимости} называется взвешенный неориентированный граф $G = (V, E, w)$, где:
\begin{itemize}
    \item $V$ --- множество вершин, определённое выше;
    \item $E \subseteq V \times V$ --- множество рёбер, такое что $(u, v) \in E$ тогда и только тогда, когда $u \neq v$ и отрезок $[u, v]$ видим;
    \item $w: E \to \mathbb{R}^+$ --- функция весов, заданная евклидовым расстоянием: $w(u, v) = \|u - v\|_2$.
\end{itemize}
\end{definition}

\subsection{Основная теорема}

Следующая теорема устанавливает фундаментальную связь между исходной непрерывной задачей и задачей поиска пути в графе.

\begin{theorem}[Основное свойство графа видимости]
Пусть $\phi^*: [0,1] \to \mathbb{R}^2$ --- оптимальная траектория в исходной задаче, а $G = (V, E, w)$ --- соответствующий граф видимости. Тогда:
\begin{enumerate}[label=\textbf{(\arabic*)}]
    \item \textbf{Существование дискретного пути:} Существует путь $p = (v_0, v_1, \dots, v_m)$ в графе $G$, где $v_0 = S$, $v_m = T$, такой что
    \[
    L(\phi^*) = \sum_{j=0}^{m-1} \|v_{j+1} - v_j\|_2 = \sum_{(u,v) \in p} w(u,v).
    \]
    
    \item \textbf{Структура оптимальной траектории:} Оптимальная траектория $\phi^*$ является ломаной линией,
        вершины которой принадлежат множеству $V$: $\{v_0, v_1, \dots, v_m\} \subseteq V$.
    
    \item \textbf{Эквивалентность задач:} Кратчайший путь в исходной задаче соответствует кратчайшему пути в графе $G$:
    \[
    \min_{\phi \ \text{допустимая}} L(\phi) = \min_{p \ \text{путь в} \ G \ \text{из} \ S \ \text{в} \ T} \sum_{(u,v) \in p} w(u,v).
    \]
\end{enumerate}
\end{theorem}

\subsection{Алгоритмическое следствие}

На основании теоремы поиск кратчайшей траектории в непрерывной области сводится к следующей двухэтапной процедуре:

\begin{enumerate}
    \item \textbf{Построение графа видимости} $G = (V, E, w)$ для заданных препятствий $\mathcal{P}$ и точек $S$, $T$.
    \item \textbf{Поиск кратчайшего пути} в графе $G$ из вершины $S$ в вершину $T$ с использованием стандартных алгоритмов теории графов, 
        таких как алгоритм Дейкстры или A*.
\end{enumerate}

Сложность решения в первую очередь определяется построением графа, которое в наивной реализации требует $O(|V|^2)$ проверок видимости
для каждой пары вершин, где $|V| = 2 + \sum_{i=1}^k |V(P_i)|$. 

\section{Построение графа видимости}
\label{sec:construction}
Для начала примем, что все препятствия обходятся против часовой стрелки, так чтобы внутренность каждого препятствия находилась слева от направления обхода.

\subsection{Наивный подход}

Наивная реализация процедуры построения графа видимости $G=(V,E,w)$ основана на полном переборе всех возможных пар вершин
и проверке видимости соответствующего отрезка.

\begin{enumerate}[label=\textbf{Шаг \arabic*.}]
    \item Формируется множество вершин $V = \{S, T\} \cup \bigcup_{i=1}^k V(P_i)$.
    \item Для каждой упорядоченной пары вершин $(u, v) \in V \times V$, где $u \neq v$, проверяется условие видимости отрезка $[u, v]$.
    \item Если отрезок $[u, v]$ видим, то в множество рёбер $E$ добавляется неориентированное ребро $(u, v)$ с весом $w(u,v) = \|u - v\|_2$.
\end{enumerate}

Сложность данного подхода определяется количеством пар вершин, равным $O(|V|^2)$,
и стоимостью проверки видимости одного отрезка, которая в наивной реализации составляет $O(n)$,
где $n$ --- общее количество рёбер во всех препятствиях. Таким образом, итоговая сложность составляет $O(|V|^2 \cdot n)$, 
что делает метод неэффективным для сцен со сложной геометрией.

\subsection{Оптимальный алгоритм на основе заметающего луча (Алгоритм Ли)}

Для эффективного построения графа видимости применяется алгоритм, предложенный Ли,
сложность которого составляет $O(|V|^2 \log |V|)$ в худшем случае.
Алгоритм последовательно для каждой вершины $s \in V$ (называемой \emph{источником}) определяет все другие видимые из неё вершины.

\begin{definition}[Заметающий луч]\label{def:processing_ray}
Для источника $s$ и текущей вершины $v$ \textbf{заметающим лучом} $L(s, v)$ называется луч с началом в $s$, проходящий через $v$.
\end{definition}

\begin{definition}[Статус луча]\label{def:ray_status}
\textbf{Статусом} на текущем угле обхода называется упорядоченное множество (например, сбалансированное дерево) рёбер препятствий,
которые пересекает заметающий луч $L(s, v)$. Рёбра упорядочены по возрастанию расстояния от точки $s$ до точки пересечения с лучом.
\end{definition}

\subsubsection{Основные этапы для одного источника}

Алгоритм для фиксированного источника $s$ состоит из следующих этапов.

\begin{enumerate}[label=\textbf{Этап \arabic*.}]
    \item \textbf{Подготовка и сортировка.}
    \begin{itemize}
        \item Все вершины $v \in V \setminus \{s\}$ проецируются на полярную систему координат с полюсом в $s$.
        \item Вершины сортируются в порядке возрастания полярного угла $\theta(s, v)$. При равенстве углов приоритет отдаётся вершине, ближайшей к $s$.
        \item Для каждого ребра $e$ препятствия, \emph{видимого} из $s$ (т.е. хотя бы один конец $e$ видим из $s$),
            определяются события: ``начало отрезка'' и ``конец отрезка'', 
            соответствующие моментам, когда вращающийся луч $L$ совпадает с направлением на концы $e$.
    \end{itemize}

    \item \textbf{Инициализация.}
    \begin{itemize}
        \item Луч $L$ устанавливается в направлении $\theta = 0$ (например, горизонтально вправо).
        \item В статус заносятся все рёбра препятствий, которые пересекает луч в этом начальном положении, упорядоченные по расстоянию от $s$.
    \end{itemize}

    \item \textbf{Последовательная обработка событий.}
    \begin{itemize}
        \item События обрабатываются в порядке возрастания полярного угла.
        \item При наступлении события ``вершина $v$'':
        \begin{itemize}
            \item Если статус пуст, то вершина $v$ \emph{видима} из $s$, и ребро $(s, v)$ добавляется в граф.
            \item Если статус не пуст, то $v$ видима только если отрезок $[s, v]$ не пересекается с ближайшим к $s$ ребром из статуса
                (т.е. $v$ находится ближе к $s$, чем точка пересечения луча $L(s, v)$ с этим ребром).
        \end{itemize}
        \item При наступлении события ``начало отрезка $e$'': ребро $e$ добавляется в статус,
            если при его рассмотрении выполняется условие обхода \emph{против часовой стрелки} для точек ($s$, начало $e$, конец $e$).
        \item При наступлении события ``конец отрезка $e$'': ребро $e$ удаляется из статуса,
            если при его рассмотрении выполняется условие обхода \emph{по часовой стрелке} для точек ($s$, конец $e$, начало $e$).
    \end{itemize}
\end{enumerate}

Повторение данной процедуры для всех $s \in V$ позволяет построить полный граф видимости $G$. 
Использование сбалансированных деревьев для хранения статуса обеспечивает сложность $O(\log |V|)$
на операцию вставки или удаления ребра, что приводит к общей сложности $O(|V|^2 \log |V|)$ для построения всего графа.

\section{Оптимизация}

Несмотря на эффективность алгоритма Ли, построенный граф видимости содержит значительное число ребер,
которые заведомо не могут принадлежать ни одному кратчайшему пути. Выявление и исключение таких ребер
на этапе построения позволяет сократить как время построения графа, так и время последующего поиска пути.

\begin{definition}[Локальная конфигурация вершины]
Для вершины $cur$, принадлежащей некоторому препятствию $P_i$, определим ее \textbf{соседей} вдоль границы этого препятствия. 
Пусть $\operatorname{prev}(cur)$ и $\operatorname{next}(cur)$ --- вершины, непосредственно предшествующая и следующая за $cur$ 
при обходе контура многоугольника $P_i$. Для начальной и конечной точек $S, T$, 
не лежащих на границах препятствий, множество соседей считается пустым.
\end{definition}

\begin{theorem}[Критерий незначащего ребра]
\label{thm:minor_edge}
Пусть $u, v \in V$ --- две различные вершины графа видимости, и пусть отрезок $[u, v]$ является видимым. 
Обозначим через $l_{uv}$ прямую, проходящую через точки $u$ и $v$. 
Ребро $(u, v)$ называется \textbf{незначащим} (\emph{minor edge}), если для каждой из этих вершин выполняются следующие условия:
\begin{itemize}
    \item вершина принадлежит некоторому препятствию;
    \item ее соседи вдоль границы этого препятствия существуют;
    \item эти соседи лежат по разные стороны от прямой $l_{uv}$.
\end{itemize}
Такое ребро не может принадлежать ни одному кратчайшему пути в графе видимости и может быть исключено из рассмотрения.
\end{theorem}

А также:

\begin{enumerate}
    \item Можно заметить следующее: 
    если мы имеем две вершины $u$ и $v$ такие, что первая из них расположена ниже второй 
    (то есть ее $y$-координата меньше), тогда при обработке вершины $v$ ребро $(u,v)$ 
    либо будет проведено, если оно допустимо, либо не будет. Следовательно, можно не рассматривать вершины, 
    у которых $y$-координата меньше текущей.
    
    \item Рассмотрим три последовательные вершины $\operatorname{prev}(cur)$, $cur$ и $\operatorname{next}(cur)$. 
    Если эти вершины образуют поворот по часовой стрелке, то вершина $cur$ является вогнутой, 
    и все инцидентные ей ребра в графе видимости являются незначащими согласно теореме~\ref{thm:minor_edge} (рис. 1). 
    Следовательно, такая вершина $cur$ может быть полностью исключена из рассмотрения в качестве кандидата на проведение ребер.
    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.6\linewidth]{images/2.png}
        \caption{Вогнутая часть препятствия}
        \label{fig:my_label}
    \end{figure}
    
    \item Если же указанные вершины образуют поворот против часовой стрелки, то вершина $cur$ является выпуклой. 
    В этом случае при обработке вершины $cur$ все ребра, построенные в вершины, лежащие внутри сектора, 
    образованного лучом из $\operatorname{prev}(cur)$ через $cur$ и лучом из $\operatorname{next}(cur)$ через $cur$, 
    будут незначащими (рис. 2). Данное множество вершин может быть исключено из проверки видимости.

    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.6\linewidth]{images/1.png}
        \caption{Выпуклая часть препятствия}
        \label{fig:my_label}
    \end{figure}
    
\end{enumerate}

В реализации последняя оптимизация может оказаться сложнее остальных.

Например, можно действовать следующим образом:
\begin{enumerate}
    \item Запускаем стандартный алгоритм Ли для источника, но заметающий луч совершает не полный оборот,
          а доходит до начала сектора, образованного лучами, описанными в пункте 2.
    \item Далее немного изменим алгоритм Ли:
        \begin{itemize}
            \item Луч $L$ устанавливается в направлении горизонтально влево (при условии, что применен п. 1).
            \item В статус аналогично вносятся все ребра препятствий, которые пересекает луч в этом начальном положении,
                  упорядоченные по расстоянию от источника.
            \item События обрабатываются в порядке убывания полярного угла.
        \end{itemize}
    \item Обработка продолжается до достижения другой границы сектора.
\end{enumerate}
В результате вершины, находящиеся внутри этого сектора, не обрабатываются, что позволяет существенно
сократить время работы алгоритма.

Можно заметить, что обработка вершин происходит независимо друг от друга,
так как для каждой вершины рассматриваются вершины только выше ее самой (те, у которых $y$-координата больше).
То есть подход, описанный выше, можно распараллелить:

Разобьем список отсортированных вершин на блоки по $k$, где $k$ — это необходимое
число задействованных потоков. И дадим каждому потоку для обработки одну вершину, 
что еще в несколько раз уменьшит время работы алгоритма.

\section{Результаты тестирования производительности}

В качестве результатов сравним время работы наивного алгоритма и оптимизированного алгоритма Ли.

\subsection{Тестовые данные}

Тестирование проводилось на планарном графе, изображенном на рисунке~\ref{fig:test_graph}. Характеристики графа:
\begin{itemize}
    \item количество вершин: \(n = 6578\);
    \item количество ребер: \(m = 6559\).
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\linewidth]{images/3.png}
    \caption{Исходный планарный граф}
    \label{fig:test_graph}
\end{figure}

После применения алгоритма построения графа видимости количество ребер увеличилось до 12668. 
Результирующий граф видимости представлен на рисунке~\ref{fig:visibility_graph}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\linewidth]{images/4.png}
    \caption{Построенный граф видимости}
    \label{fig:visibility_graph}
\end{figure}

\subsection{Характеристики тестового стенда}

Тестирование проводилось на машине со следующими характеристиками:
\begin{itemize}
    \item процессор: AMD Ryzen 5 3600 6-Core Processor (6 физических ядер, 12 логических потоков);
    \item тактовая частота: базовая 3.6 ГГц, максимальная 4.2 ГГц;
    \item оперативная память: 8 ГБ;
    \item операционная система: Ubuntu 24.04.3 LTS.
\end{itemize}

\subsection{Результаты замеров времени}

В таблице~\ref{tab:results} представлены результаты замеров времени работы различных реализаций алгоритмов.

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Алгоритм} & \textbf{Время выполнения, с} \\
        \hline
        Наивный алгоритм (O(n²·m)) & 583 \\
        \hline
        Алгоритм Ли с оптимизациями & 1,231 \\
        \hline
        Алгоритм Ли с оптимизациями и распараллеливанием & 0,464 \\
        \hline
    \end{tabular}
    \caption{Сравнение времени работы алгоритмов}
    \label{tab:results}
\end{table}

Как видно из полученных результатов, оптимизированный алгоритм Ли показывает
значительный прирост производительности по сравнению с наивной реализацией.
Дополнительное распараллеливание вычислений позволяет ускорить работу еще в ~2.5 раза.

\section*{Заключение}

В результате проделанной работы удалось значительно ускорить алгоритм Ли для построения графа видимости.


\newpage

\begin{thebibliography}{99}
\bibitem{nilsson69}
Nilsson N.~J. A mobile automaton: An application of artificial intelligence techniques //
Proceedings of the 1st International Joint Conference on Artificial Intelligence (IJCAI'69). 
-- 1969. -- P. 509--520.

\bibitem{lee78}
Lee D.~T. Proximity and reachability in the plane : Ph.D. Thesis / University of Illinois 
at Urbana-Champaign. -- 1978.

\end{thebibliography}
\end{document}
